(ns droid.data
  (:require [clojure.java.io :as io]
            [clojure.string :as string]
            [environ.core :refer [env]]
            [me.raynes.conch.low-level :as sh]
            [droid.config :refer [config]]
            [droid.dir :refer [get-workspace-dir get-temp-dir]]
            [droid.log :as log]
            [droid.make :as make]))

(defn- fail
  "Logs a fatal error and then exits with a failure status (unless the server is running in
  development mode."
  [errorstr]
  (log/fatal errorstr)
  (when-not (= (:op-env config) :dev)
    (System/exit 1)))

(def secrets
  "Secret IDs and passcodes, loaded from environment variables."
  ;; Note that the env package maps an environment variable named ENV_VAR into the keyword
  ;; :env-var, so below :github-client-id is associated with GITHUB_CLIENT_ID and similarly for
  ;; :github-client-secret.
  (->> [:github-client-id :github-client-secret]
       (map #(let [val (env %)]
               (if (nil? val)
                 ;; Raise an error if the environment variable isn't found:
                 (-> % (str " not set") (fail))
                 ;; Otherwise return a hashmap with one entry:
                 {% val})))
       ;; Merge the hashmaps corresponding to each environment variable into one hashmap:
       (apply merge)))

(defn- delete-recursively
  "Delete all files and directories recursively under and including topname."
  [topname]
  (let [filenames (->> topname (io/file) (.list))]
    (doseq [filename filenames]
      (let [path (str topname "/" filename)]
        (if (-> path (io/file) (.isDirectory))
          (delete-recursively path)
          (io/delete-file path true)))))
  (io/delete-file topname true))

(defn- initialize-project-branches
  "Initialize a hashmap containing information about the contents and status of every branch
  in the workspace of the given project."
  [project]
  (let [project-workspace-dir (get-workspace-dir project)
        project-temp-dir (get-temp-dir project)]
    (when (->> project-workspace-dir
               (io/file)
               (#(or (not (.exists %)) (not (.isDirectory %)))))
      (fail
       (str project-workspace-dir " doesn't exist or isn't a directory.")))

    ;; Destroy and recreate the temp/ directory:
    (delete-recursively project-temp-dir)
    (.mkdir (io/file project-temp-dir))
    ;; Each sub-directory of the workspace represents a branch with the same name.
    (let [branch-dirs (->> project-workspace-dir (io/file) (.list))]
      (->> (for [branch-dir branch-dirs]
             (when (-> project-workspace-dir (str branch-dir) (io/file) (.isDirectory))
               ;; Create a sub-directory with the same name as the branch in the
               ;; temp/ directory:
               (-> project-temp-dir (str branch-dir) (io/file) (.mkdir))
               ;; Create an empty console.txt file in the branch's sub-directory in temp/:
               (-> project-temp-dir (str branch-dir "/console.txt") (spit nil))
               ;; Create a hashmap entry mapping the branch name to the contents of its
               ;; corresponding workspace directory. These contents are represented by a hashmap
               ;; mapping a keywordized version of each filename/directory to a further hashmap
               ;; representing that file/directory. In addition to entries corresponding to
               ;; files and directories, a number of entries for meta-content are also present;
               ;; initially this is just the branch-name and project-name, for convenience.
               ;; The hashmap representing the branch as a whole is encapsulated inside an
               ;; agent, which will be used to serialise updates to the branch info.
               (-> branch-dir
                   (keyword)
                   (hash-map (agent {:project-name project, :branch-name branch-dir}
                                    :error-mode :continue
                                    :error-handler (fn [the-agent exception]
                                                     (log/error (.getMessage exception))))))))
           ;; Combine the sequence of hashmap entries generated by the for loop into a single map:
           (apply merge)))))

;; TODO: This should be an atom or something mutable, and there should be a function to refresh it,
;; and a corresponding button on one of the pages to launch the refresh. It should also be refreshed
;; whenever the user creates a new branch or deletes one, etc.
(def branches
  "A hashmap with information for every branch in the workspace of every managed project. The keys
  of this hashmap are the keywordized names of the managed projects."
  (->> (for [project (->> config :projects (keys))]
         (-> project
             (keyword)
             (hash-map (initialize-project-branches project))))
       (apply merge)))

(defn refresh-branch
  "Given a map containing information on the contents of the directory corresponding to the given
  branch in the workspace, generate an updated version of the map by re-reading the directory
  contents and return it."
  [{:keys [branch-name project-name] :as branch}]
  (letfn [(parse-git-status [text]
            (let [[branch-status & file-statuses] (string/split-lines text)
                  branch-re "(((\\S+)\\.{3}(\\S+)|(\\S+)))"
                  ahead-behind-re "( \\[(ahead (\\d+))?(, )?(behind (\\d+))?\\])?"
                  pattern (re-pattern (str "## " branch-re ahead-behind-re))
                  [_ _ _ local remote local-alt _ _ ahead _ _ behind] (re-find pattern
                                                                               branch-status)]
              {:raw-text text
               :local (or local local-alt)
               :remote remote
               :ahead (if (nil? ahead) 0 (Integer/parseInt ahead))
               :behind (if (nil? behind) 0 (Integer/parseInt behind))}))]
    (let [branch-workspace-dir (get-workspace-dir project-name branch-name)
          branch-temp-dir (get-temp-dir project-name branch-name)
          git-status (let [process (sh/proc "git" "status" "--short" "--branch" "--porcelain"
                                            :dir (get-workspace-dir project-name branch-name))
                           exit-code (future (sh/exit-code process))]
                       (if (= @exit-code 0)
                         (parse-git-status (sh/stream-to-string process :out))
                         (do
                           (log/error
                            "Error retrieving git status for branch" branch-name "of project"
                            project-name ":" (sh/stream-to-string process :err))
                           {})))]
      ;; The contents of the directory for the branch are represented by a hashmap, mapping the
      ;; keywordized name of each file/sub-directory in the branch to nested hashmap with
      ;; info about that file/sub-directory. This info is at a minimum the file/sub-directory's
      ;; non-keywordized name. Other info may be added later.
      (-> (->> branch-workspace-dir
               (io/file)
               (.list)
               ;; We skip the Makefile for now. It will be populated separately later on.
               (map #(when-not (= % "Makefile")
                       (hash-map (keyword %) (hash-map :name %))))
               ;; Merge the sequence of hashmaps just generated into a larger hashmap:
               (apply merge)
               ;; Merge the newly generated hashmap with the currently saved hashmap:
               (merge branch)
               ;; Merge in the Makefile info:
               (merge (make/get-makefile-info branch)))
          ;; Add the git status of the branch:
          (assoc :git-status git-status)
          ;; Add the console contents and info about the running process, if any:
          (assoc :console (-> branch-temp-dir (str "/console.txt") (slurp)))
          (#(if (and (not (->> % :process nil?))
                     (not (->> % :exit-code nil?))
                     (not (->> % :exit-code realized?)))
              (assoc % :run-time (->> branch :start-time (- (System/currentTimeMillis))))
              %))))))
