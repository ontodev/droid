(ns droid.data
  (:require [clojure.java.io :as io]
            [clojure.string :as string]
            [environ.core :refer [env]]
            [me.raynes.conch.low-level :as sh]
            [droid.config :refer [config]]
            [droid.dir :refer [get-workspace-dir get-temp-dir]]
            [droid.log :as log]
            [droid.make :as make]))

(defn- fail
  "Logs a fatal error and then exits with a failure status (unless the server is running in
  development mode."
  [errorstr]
  (log/fatal errorstr)
  (when-not (= (:op-env config) :dev)
    (System/exit 1)))

(def secrets
  "Secret IDs and passcodes, loaded from environment variables."
  ;; Note that the env package maps an environment variable named ENV_VAR into the keyword
  ;; :env-var, so below :github-client-id is associated with GITHUB_CLIENT_ID and similarly for
  ;; :github-client-secret.
  (->> [:github-client-id :github-client-secret]
       (map #(let [val (env %)]
               (if (nil? val)
                 ;; Raise an error if the environment variable isn't found:
                 (-> % (str " not set") (fail))
                 ;; Otherwise return a hashmap with one entry:
                 {% val})))
       ;; Merge the hashmaps corresponding to each environment variable into one hashmap:
       (apply merge)))

(defn- delete-recursively
  "Delete all files and directories recursively under and including topname."
  [topname]
  (let [filenames (->> topname (io/file) (.list))]
    (doseq [filename filenames]
      (let [path (str topname "/" filename)]
        (if (-> path (io/file) (.isDirectory))
          (delete-recursively path)
          (io/delete-file path true)))))
  (io/delete-file topname true))

(defn- initialize-project-branches
  "Initialize a hashmap containing information about the contents and status of every branch
  in the workspace of the given project. If reset? is true, then clobber the temporary data
  for every branch and recreate it."
  [project reset?]
  (let [project-workspace-dir (get-workspace-dir project)
        project-temp-dir (get-temp-dir project)]
    (when (->> project-workspace-dir
               (io/file)
               (#(or (not (.exists %)) (not (.isDirectory %)))))
      (fail
       (str project-workspace-dir " doesn't exist or isn't a directory.")))

    (when reset?
      ;; Destroy and recreate the temp/ directory:
      (delete-recursively project-temp-dir)
      (.mkdir (io/file project-temp-dir)))
    ;; Each sub-directory of the workspace represents a branch with the same name.
    (let [branch-dirs (->> project-workspace-dir (io/file) (.list))]
      (->> (for [branch-dir branch-dirs]
             (when (-> project-workspace-dir (str branch-dir) (io/file) (.isDirectory))
               (when reset?
                 ;; Create a sub-directory with the same name as the branch in the
                 ;; temp/ directory:
                 (-> project-temp-dir (str branch-dir) (io/file) (.mkdir))
                 ;; Create an empty console.txt file in the branch's sub-directory in temp/:
                 (-> project-temp-dir (str branch-dir "/console.txt") (spit nil)))
               ;; Create a hashmap entry mapping the branch name to the contents of its
               ;; corresponding workspace directory. These contents are represented by a hashmap
               ;; mapping a keywordized version of each filename/directory to a further hashmap
               ;; representing that file/directory. In addition to entries corresponding to
               ;; files and directories, a number of entries for meta-content are also present;
               ;; initially this is just the branch-name and project-name, for convenience.
               ;; The hashmap representing the branch as a whole is encapsulated inside an
               ;; agent, which will be used to serialise updates to the branch info.
               (-> branch-dir
                   (keyword)
                   (hash-map (agent {:project-name project, :branch-name branch-dir}
                                    :error-mode :continue
                                    :error-handler (fn [the-agent exception]
                                                     (log/error (.getMessage exception))))))))
           ;; Combine the sequence of hashmap entries generated by the for loop into a single map:
           (apply merge)))))

(defn refresh-branches
  "Returns a hashmap with information for every branch in the workspace of every managed project.
  The keys of this hashmap are the keywordized names of the managed projects. If the reset?
  parameter is true, then it will reset the branch data in addition to refreshing it. If reset?
  is not provided it defaults to false."
  ([old-branches reset?]
   ;; Note that the argument 'old-branches' is not used, but is required, since typically this
   ;; function will be called through send-off on the agent that manages all of the project
   ;; branches. We may want to use old-branches in the future, for example if we need to increase
   ;; the efficiency of this refresh.
   (->> (for [project (->> config :projects (keys))]
          (-> project
              (keyword)
              (hash-map (initialize-project-branches project reset?))))
        (apply merge)))

  ([old-branches]
   (refresh-branches old-branches false)))

(def branches
  "An agent to handle access to the hashmap that contains info on all of the branches managed by the
  server instance."
  ;; Initialize the agent using the refresh-branches function:
  (agent (refresh-branches {})
         :error-mode :continue
         :error-handler (fn [the-agent exception]
                          (log/error (.getMessage exception)))))

(defn refresh-branch
  "Given a map containing information on the contents of the directory corresponding to the given
  branch in the workspace, generate an updated version of the map by re-reading the directory
  contents and return it."
  [{:keys [branch-name project-name] :as branch}]
  (letfn [(parse-git-status [text]
            ;; Parses the porcelain git status short output and extracts the branch tracking info
            ;; and info about uncommitted files.
            (let [[branch-status & file-statuses] (string/split-lines text)
                  local-remote-re "(((\\S+)\\.{3}(\\S+)|(\\S+)))"
                  ahead-behind-re "( \\[(ahead (\\d+))?(, )?(behind (\\d+))?\\])?"
                  tracking-pattern (re-pattern (str "## " local-remote-re ahead-behind-re))
                  [_ _ _ local remote local-alt _ _ ahead _ _ behind] (re-find tracking-pattern
                                                                               branch-status)]
              {:raw-text text
               :local (or local local-alt)
               :remote remote
               :ahead (if (nil? ahead) 0 (Integer/parseInt ahead))
               :behind (if (nil? behind) 0 (Integer/parseInt behind))
               ;; Simple yes or no to the question of whether there are files to commit:
               :uncommitted? (-> #(not (string/starts-with? % "??"))
                                 (some file-statuses)
                                 (boolean))}))]
    (let [branch-workspace-dir (get-workspace-dir project-name branch-name)
          branch-temp-dir (get-temp-dir project-name branch-name)
          git-status (let [process (sh/proc "git" "status" "--short" "--branch" "--porcelain"
                                            :dir (get-workspace-dir project-name branch-name))
                           exit-code (future (sh/exit-code process))]
                       (if (= @exit-code 0)
                         (parse-git-status (sh/stream-to-string process :out))
                         (do
                           (log/error
                            "Error retrieving git status for branch" branch-name "of project"
                            project-name ":" (sh/stream-to-string process :err))
                           {})))]
      ;; The contents of the directory for the branch are represented by a hashmap, mapping the
      ;; keywordized name of each file/sub-directory in the branch to nested hashmap with
      ;; info about that file/sub-directory. This info is at a minimum the file/sub-directory's
      ;; non-keywordized name. Other info may be added later.
      (-> (->> branch-workspace-dir
               (io/file)
               (.list)
               ;; We skip the Makefile for now. It will be populated separately later on.
               (map #(when-not (= % "Makefile")
                       (hash-map (keyword %) (hash-map :name %))))
               ;; Merge the sequence of hashmaps just generated into a larger hashmap:
               (apply merge)
               ;; Merge the newly generated hashmap with the currently saved hashmap:
               (merge branch)
               ;; Merge in the Makefile info:
               (merge (make/get-makefile-info branch)))
          ;; Add the git status of the branch:
          (assoc :git-status git-status)
          ;; Add the console contents and info about the running process, if any:
          (assoc :console (-> branch-temp-dir (str "/console.txt") (slurp)))
          (#(if (and (not (->> % :process nil?))
                     (not (->> % :exit-code nil?))
                     (not (->> % :exit-code realized?)))
              (assoc % :run-time (->> branch :start-time (- (System/currentTimeMillis))))
              %))))))
